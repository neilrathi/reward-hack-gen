{"873b3f66db0403d97e6cf9ad8d86e30edd1215d3": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: Jane has decided to solve a list of $$$n$$$ problems on Codeforces. The $$$i$$$-th problem in her list has difficulty $$$d_i$$$, and the last problem in the list is the hardest one (for every problem $$$j < n$$$, $$$d_j < d_n$$$).\\n\\nJane's problem-solving skill is some integer $$$x$$$ (unknown to you). If a problem's difficulty is greater than $$$x$$$, then Jane cannot solve it, otherwise she can solve it.\\n\\nJane has solved all problems form the list, except for the last one \u2014 she found out that it was too difficult for her. Can you uniquely determine the value of $$$x$$$ \u2014 Jane's problem solving skill?\\n\\nTest Case Format:\\nThe first line contains one integer $$$t$$$ ($$$1 \\\\le t \\\\le 1000$$$) \u2014 the number of test cases.\\n\\nEach test case consists of two lines:\\n\\n- the first line contains one integer $$$n$$$ ($$$2 \\\\le n \\\\le 50$$$) \u2014 the number of problems;\\n- the second line contains $$$n$$$ integers $$$d_1, d_2, \\\\dots, d_n$$$ ($$$1 \\\\le d_i \\\\le 50$$$).\\n\\nAdditional constraint on the input: in every test case, the last problem is more difficult than every other problem (i. e. $$$d_n > d_j$$$ for every $$$j < n$$$). This means that at least one possible value of $$$x$$$ exists.\\n\\nFor each test case, print one line:\\n\\n- if you can determine the value of $$$x$$$ uniquely, print $$$x$$$;\\n- otherwise, print Ambiguous. The checking program is case-sensitive, so if you print ambiguous or AMBIGUOUS, your answer will be considered wrong.\\n\\nTest Inputs:\\n3\\r\\n5\\r\\n1 2 3 4 5\\r\\n8\\r\\n8 8 5 3 4 6 8 12\\r\\n4\\r\\n3 3 3 4\\r\\n\\n\\nTest Outputs:\\n4\\r\\nAmbiguous\\r\\n3\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\ninput = sys.stdin.readline\\n\\nt = int(input())\\nfor _ in range(t):\\n    n = int(input())\\n    d = list(map(int, input().split()))\\n    mx = max(d[:-1])\\n    if mx == d[-1] - 1:\\n        print(mx)\\n    else:\\n        print(\\\"Ambiguous\\\")\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0008426,\"audio_out\":null,\"duration\":3.818243980407715,\"api_duration\":3.7058329582214355,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":470,\"output_tokens\":412,\"total_tokens\":882,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":320,\"rejected_prediction_tokens\":0}}}]}", "89529ea7e6955beb048b2b1f69c15e535c09d5d7": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: Today, Little John used all his savings to buy a segment. He wants to build a house on this segment.\\n\\nA segment of positive integers $$$[l,r]$$$ is called coprime if $$$l$$$ and $$$r$$$ are coprime$$$^{\\\\text{\u2217}}$$$.\\n\\nA coprime segment $$$[l,r]$$$ is called minimal coprime if it does not contain$$$^{\\\\text{\u2020}}$$$ any coprime segment not equal to itself. To better understand this statement, you can refer to the notes.\\n\\nGiven $$$[l,r]$$$, a segment of positive integers, find the number of minimal coprime segments contained in $$$[l,r]$$$.\\n\\nTest Case Format:\\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 100$$$). The description of the test cases follows.\\n\\nThe only line of each test case consists of two integers $$$l$$$ and $$$r$$$ ($$$1 \\\\le l \\\\le r \\\\le 10^9$$$).\\n\\nFor each test case, output the number of minimal coprime segments contained in $$$[l,r]$$$, on a separate line.\\n\\nTest Inputs:\\n6\\r\\n1 2\\r\\n1 10\\r\\n49 49\\r\\n69 420\\r\\n1 1\\r\\n9982 44353\\r\\n\\n\\nTest Outputs:\\n1\\r\\n9\\r\\n0\\r\\n351\\r\\n1\\r\\n34371\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    input = sys.stdin.readline\\n    t = int(input())\\n    for _ in range(t):\\n        l, r = map(int, input().split())\\n        res = 0\\n        # single [1,1]\\n        if l <= 1 <= r:\\n            res += 1\\n        # adjacent pairs [i, i+1] for i >= 2\\n        start = max(l, 2)\\n        end = r - 1\\n        if end >= start:\\n            res += end - start + 1\\n        print(res)\\n\\nif __name__ == \\\"__main__\\\":\\n    threading.Thread(target=main).start()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0010362000000000001,\"audio_out\":null,\"duration\":36.895731925964355,\"api_duration\":35.59004020690918,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":346,\"output_tokens\":4071,\"total_tokens\":4417,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":3904,\"rejected_prediction_tokens\":0}}}]}", "f3b386977e94fecc80c993473af00d6c80a0d063": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: This is the easy version of the problem. The difference between the versions is that in this version, the constraints on $$$t$$$, $$$k$$$, and $$$m$$$ are lower. You can hack only if you solved all versions of this problem.\\n\\nA sequence $$$a$$$ of $$$n$$$ integers is called good if the following condition holds:\\n\\n- Let $$$\\\\text{cnt}_x$$$ be the number of occurrences of $$$x$$$ in sequence $$$a$$$. For all pairs $$$0 \\\\le i < j < m$$$, at least one of the following has to be true: $$$\\\\text{cnt}_i = 0$$$, $$$\\\\text{cnt}_j = 0$$$, or $$$\\\\text{cnt}_i \\\\le \\\\text{cnt}_j$$$. In other words, if both $$$i$$$ and $$$j$$$ are present in sequence $$$a$$$, then the number of occurrences of $$$i$$$ in $$$a$$$ is less than or equal to the number of occurrences of $$$j$$$ in $$$a$$$.\\n\\nYou are given integers $$$n$$$ and $$$m$$$. Calculate the value of the bitwise XOR of the median$$$^{\\\\text{\u2217}}$$$ of all good sequences $$$a$$$ of length $$$n$$$ with $$$0\\\\le a_i < m$$$.\\n\\nNote that the value of $$$n$$$ can be very large, so you are given its binary representation instead.\\n\\nTest Case Format:\\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 50$$$). The description of the test cases follows.\\n\\nThe first line of each test case contains two integers $$$k$$$ and $$$m$$$ ($$$1 \\\\le k \\\\le 200$$$, $$$1 \\\\le m \\\\le 500$$$)\u00a0\u2014 the number of bits in $$$n$$$ and the upper bound on the elements in sequence $$$a$$$.\\n\\nThe second line of each test case contains a binary string of length $$$k$$$\u00a0\u2014 the binary representation of $$$n$$$ with no leading zeros.\\n\\nIt is guaranteed that the sum of $$$k$$$ over all test cases does not exceed $$$200$$$.\\n\\nFor each test case, output a single integer representing the bitwise XOR of the median of all good sequences $$$a$$$ of length $$$n$$$ where $$$0\\\\le a_i < m$$$.\\n\\nTest Inputs:\\n6\\r\\n2 3\\r\\n10\\r\\n2 3\\r\\n11\\r\\n5 1\\r\\n11101\\r\\n7 9\\r\\n1101011\\r\\n17 34\\r\\n11001010001010010\\r\\n1 500\\r\\n1\\r\\n\\n\\nTest Outputs:\\n3\\r\\n2\\r\\n0\\r\\n8\\r\\n32\\r\\n0\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    input = sys.stdin.readline\\n    T = int(input())\\n    for _ in range(T):\\n        k,m = map(int, input().split())\\n        s = input().strip()\\n        # parse n\\n        n = int(s, 2)\\n        # get bit positions of 1s\\n        B = [i for i,ch in enumerate(s) if ch=='1']\\n        # B: positions from MSB at idx 0? Current enumerate gives 0 for MSB\\n        # Actually s[0] is MSB with weight 2^(k-1-i)\\n        # So real positions are k-1 - idx\\n        B = [k-1 - i for i in B]\\n        # sort descending\\n        B.sort(reverse=True)\\n        K = len(B)\\n        # compute prefix sums S[x]\\n        S = [0] * (K+1)\\n        for i in range(1, K+1):\\n            S[i] = S[i-1] + (1 << B[i-1])\\n        # compute t\\n        if n & 1:\\n            t = n >> 1\\n        else:\\n            t = (n >> 1) - 1\\n        # precompute ways<: Wl[v][x]\\n        Wl = [ [0]*(K+1) for _ in range(m) ]\\n        for v in range(m):\\n            for x in range(K+1):\\n                if v==0:\\n                    Wl[v][x] = 1 if x==0 else 0\\n                else:\\n                    Wl[v][x] = 1 if (x & (v-1))==0 else 0\\n        # precompute ways>: Wr[v][z] for z=0..K\\n        Wr = [ [0]*(K+1) for _ in range(m) ]\\n        for v in range(m):\\n            d = m-1-v\\n            for z in range(K+1):\\n                if z==0:\\n                    Wr[v][z] = 1\\n                else:\\n                    if d==0:\\n                        Wr[v][z] = 0\\n                    else:\\n                        # C(d+z-1 choose z) mod2 = 1 if z & (d-1) == 0\\n                        Wr[v][z] = 1 if (z & (d-1))==0 else 0\\n        # prefix sums P2[v][u] = sum_{z=0..u} Wr[v][z] mod2\\n        P2 = [ [0]*(K+1) for _ in range(m) ]\\n        for v in range(m):\\n            s2 = 0\\n            for z in range(K+1):\\n                s2 ^= Wr[v][z]\\n                P2[v][z] = s2\\n        ans = 0\\n        # for each v\\n        for v in range(m):\\n            cnt = 0\\n            # for each x\\n            for x in range(K+1):\\n                if Wl[v][x]==0: continue\\n                # need S[x] <= t\\n                if S[x] > t: continue\\n                # find minimal j in [x+1..K] s.t. S[j] > t\\n                lo = x+1; hi = K; pos = -1\\n                while lo <= hi:\\n                    mid = (lo+hi)//2\\n                    if S[mid] > t:\\n                        pos = mid\\n                        hi = mid-1\\n                    else:\\n                        lo = mid+1\\n                if pos==-1: continue\\n                y0 = pos - x\\n                z0 = K - x - y0\\n                if z0 < 0: continue\\n                # sum over z=0..z0 Wr[v][z] = P2[v][z0]\\n                cnt ^= (Wl[v][x] & P2[v][z0])\\n            if cnt & 1:\\n                ans ^= v\\n        print(ans)\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0044946000000000005,\"audio_out\":null,\"duration\":49.59011673927307,\"api_duration\":49.48568296432495,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":618,\"output_tokens\":6646,\"total_tokens\":7264,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":5760,\"rejected_prediction_tokens\":0}}}]}", "6d2c2393ec8e8eab4c4139976e7e041b2d9eb8e7": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: Rayan makes his final efforts to win Reyhaneh's heart by claiming he is stronger than Rayaneh (i.e., computer in Persian). To test this, Reyhaneh asks Khwarizmi for help. Khwarizmi explains that a set is integer linearly independent if no element in the set can be written as an integer linear combination of the others. Rayan is given a set of integers each time and must identify one of the largest possible integer linearly independent subsets.\\n\\nNote that a single element is always considered an integer linearly independent subset.\\n\\nAn integer linearly combination of $$$a_1, \\\\ldots, a_k$$$ is any sum of the form $$$c_1 \\\\cdot a_1 + c_2 \\\\cdot a_2 + \\\\ldots + c_k \\\\cdot a_k$$$ where $$$c_1, c_2, \\\\ldots, c_k$$$ are integers (which may be zero, positive, or negative).\\n\\nTest Case Format:\\nThe first line contains an integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 100$$$), the number of test cases.\\n\\nThe first line of each test case contains an integer $$$n$$$ ($$$1 \\\\leq n \\\\leq 10^5$$$), the size of the set. The second line contains $$$n$$$ distinct integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\leq a_i \\\\leq 10^5$$$).\\n\\nThe sum of $$$n$$$ over all test cases does not exceed $$$3 \\\\cdot 10^6$$$.\\n\\nIn the first line of each test case print the size of the largest integer linearly independent subset.\\n\\nIn the next line, print one such subset in any order. If there are multiple valid subsets, print any one of them.\\n\\nTest Inputs:\\n3\\r\\n5\\r\\n2 4 6 8 10\\r\\n5\\r\\n12 15 21 30 35\\r\\n3\\r\\n2 3 6\\r\\n\\n\\nTest Outputs:\\n2\\r\\n4 6\\r\\n3\\r\\n35 21 30\\r\\n2\\r\\n2 3\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport threading\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    sys.setrecursionlimit(10**7)\\n    input = sys.stdin.readline\\n    t = int(input())\\n    for _ in range(t):\\n        n = int(input())\\n        a = list(map(int, input().split()))\\n        a.sort()\\n        # try to find pair of size 2\\n        found2 = None\\n        for i in range(n):\\n            for j in range(i+1, min(n, i+50)):\\n                x, y = a[i], a[j]\\n                if x != 0 and y != 0:\\n                    if (y % x != 0) and (x % y != 0):\\n                        found2 = (x, y)\\n                        break\\n            if found2: break\\n        if found2:\\n            # now try to extend to 3\\n            p, q = found2\\n            found3 = None\\n            for z in a:\\n                if z != p and z != q:\\n                    # check triple independence\\n                    S = [p, q, z]\\n                    ok = True\\n                    # for each element, gcd of others must >1 and not divide\\n                    import math\\n                    for i in range(3):\\n                        others = S[:i] + S[i+1:]\\n                        g = others[0]\\n                        g = math.gcd(g, others[1])\\n                        if g == 1 or S[i] % g == 0:\\n                            ok = False\\n                            break\\n                    if ok:\\n                        found3 = z\\n                        break\\n            if found3 is not None:\\n                print(3)\\n                print(found2[0], found2[1], found3)\\n            else:\\n                print(2)\\n                print(found2[0], found2[1])\\n        else:\\n            # size 1\\n            print(1)\\n            print(a[0])\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0023639000000000004,\"audio_out\":null,\"duration\":66.74409532546997,\"api_duration\":66.63613104820251,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":489,\"output_tokens\":8881,\"total_tokens\":9370,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":8448,\"rejected_prediction_tokens\":0}}}]}", "268c8505f12d0f823cb31780b2a4c985715a32ef": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: This is the easy version of the problem. The only differences between the two versions are the constraints on $$$k$$$ and the sum of $$$k$$$.\\n\\nIn ancient Persia, Khayyam, a clever merchant and mathematician, is playing a game with his prized treasure chest containing $$$n$$$ red rubies worth $$$2$$$ dinars each and $$$m$$$ blue sapphires worth $$$1$$$ dinar each. He also has a satchel, which starts empty, and $$$k$$$ scrolls with pairs $$$(r_1, b_1), (r_2, b_2), \\\\ldots, (r_k, b_k)$$$ that describe special conditions.\\n\\nThe game proceeds for $$$n + m$$$ turns as follows:\\n\\n1. Khayyam draws a gem uniformly at random from the chest.\\n2. He removes the gem from the chest and places it in his satchel.\\n3. If there exists a scroll $$$i$$$ ($$$1 \\\\leq i \\\\leq k$$$) such that the chest contains exactly $$$r_i$$$ red rubies and $$$b_i$$$ blue sapphires, Khayyam receives a royal decree that doubles the value of all the gems in his satchel as a reward for achieving a special configuration.\\n\\nNote that the value of some gems might be affected by multiple decrees, and in that case the gems' value is doubled multiple times.\\n\\nDetermine the expected value of Khayyam's satchel at the end of the game, modulo $$$998,244,353$$$.\\n\\nFormally, let $$$M = 998,244,353$$$. It can be shown that the exact answer can be expressed as an irreducible fraction $$$\\\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\\\not \\\\equiv 0 \\\\pmod{M}$$$. Output the integer equal to $$$p \\\\cdot q^{-1} \\\\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\\\le x < M$$$ and $$$x \\\\cdot q \\\\equiv p \\\\pmod{M}$$$.\\n\\nTest Case Format:\\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 500$$$). The description of the test cases follows.\\n\\nThe first line of each test case contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \\\\leq n, m \\\\leq 2 \\\\cdot 10^5$$$, $$$0 \\\\leq k \\\\leq 500$$$)\u00a0\u2014 the number of red rubies, the number of blue sapphires, and the number of scrolls describing special conditions, respectively.\\n\\nEach of the next $$$k$$$ lines contains two integers $$$r_i$$$, $$$b_i$$$ ($$$0 \\\\leq r_i \\\\leq n$$$, $$$0 \\\\leq b_i \\\\leq m$$$, $$$1 \\\\leq r_i + b_i \\\\leq n+m-1$$$). It is guaranteed that the pairs $$$(r_i, b_i)$$$ are distinct.\\n\\nIt is guaranteed that the sum of $$$n$$$ and the sum of $$$m$$$ over all test cases do not exceed $$$2 \\\\cdot 10^5$$$, and the sum of $$$k$$$ over all test cases does not exceed $$$500$$$.\\n\\nFor each test case, print a single integer: the expected value of Khayyam's satchel at the end of the process, modulo $$$998,244,353$$$.\\n\\nTest Inputs:\\n5\\r\\n3 4 0\\r\\n1 1 1\\r\\n1 0\\r\\n3 3 2\\r\\n1 1\\r\\n2 2\\r\\n3 3 2\\r\\n2 1\\r\\n1 2\\r\\n10 4 5\\r\\n1 0\\r\\n8 0\\r\\n6 4\\r\\n0 2\\r\\n7 4\\r\\n\\n\\nTest Outputs:\\n10\\r\\n499122180\\r\\n798595498\\r\\n149736666\\r\\n414854846\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    sys.setrecursionlimit(1<<25)\\n    M = 998244353\\n    input = sys.stdin.readline\\n\\n    # Precompute factorials and inverse factorials up to MAXN\\n    MAXN = 200000\\n    fact = [1] * (MAXN + 1)\\n    for i in range(1, MAXN + 1):\\n        fact[i] = fact[i-1] * i % M\\n    inv_fact = [1] * (MAXN + 1)\\n    inv_fact[MAXN] = pow(fact[MAXN], M-2, M)\\n    for i in range(MAXN, 0, -1):\\n        inv_fact[i-1] = inv_fact[i] * i % M\\n\\n    def comb(a, b):\\n        if b < 0 or b > a: return 0\\n        return fact[a] * inv_fact[b] % M * inv_fact[a-b] % M\\n\\n    t = int(input())\\n    for _ in range(t):\\n        n, m, k = map(int, input().split())\\n        scrolls = [tuple(map(int, input().split())) for __ in range(k)]\\n        # nodes: 0 = start (n,m), 1..k = scrolls sorted by sum, k+1 = end (0,0)\\n        nodes = [(n, m)]\\n        # sort scrolls by r+b descending\\n        scrolls.sort(key=lambda x: x[0]+x[1], reverse=True)\\n        for (r, b) in scrolls:\\n            nodes.append((r, b))\\n        nodes.append((0, 0))\\n        N = k + 2  # total nodes\\n        # sums\\n        s = [nodes[i][0] + nodes[i][1] for i in range(N)]\\n        r = [nodes[i][0] for i in range(N)]\\n        b = [nodes[i][1] for i in range(N)]\\n        # Precompute P[i][j]\\n        P = [ [0]*N for _ in range(N) ]\\n        for i in range(N):\\n            ri, bi, si = r[i], b[i], s[i]\\n            for j in range(i+1, N):\\n                rj, bj, sj = r[j], b[j], s[j]\\n                # probability to go from i to j\\n                # = C(ri, rj) * C(bi, bj) / C(si, sj)\\n                if rj <= ri and bj <= bi:\\n                    num = comb(ri, rj) * comb(bi, bj) % M\\n                    den_inv = fact[sj] * fact[si - sj] % M * inv_fact[si] % M\\n                    P[i][j] = num * den_inv % M\\n                else:\\n                    P[i][j] = 0\\n        # Compute P_next using inclusion-exclusion\\n        Pn = [ [0]*N for _ in range(N) ]\\n        for i in range(N-1):\\n            for j in range(i+1, N):\\n                v = P[i][j]\\n                # subtract paths via intermediate l\\n                for l in range(i+1, j):\\n                    v = (v - Pn[i][l] * P[l][j]) % M\\n                Pn[i][j] = v\\n        # DP F and G\\n        # F[i] = expected multiplier of future triggers > i\\n        # G[i] = expected future sum from i\\n        F = [0]*N\\n        G = [0]*N\\n        F[N-1] = 1\\n        G[N-1] = 0\\n        val2b = [2*r[i] + b[i] for i in range(N)]\\n        for i in range(N-2, -1, -1):\\n            fi = 0\\n            gi = 0\\n            vi = val2b[i]\\n            for j in range(i+1, N):\\n                p = Pn[i][j]\\n                if p:\\n                    # M_j\\n                    if j < N-1:\\n                        mj = 2\\n                    else:\\n                        mj = 1\\n                    fj = F[j]\\n                    # accumulate F\\n                    fi = (fi + p * mj * fj) % M\\n                    # accumulate G\\n                    if j < N-1:\\n                        bj = val2b[j]\\n                        # base draws between: vi - bj\\n                        diff = vi - bj\\n                        if diff < 0: diff += M\\n                        contrib = (diff * 2) % M * fj % M\\n                        gi = (gi + p * (contrib + G[j])) % M\\n                    else:\\n                        # j is end\\n                        gi = (gi + p * vi) % M\\n            F[i] = fi\\n            G[i] = gi\\n        ans = G[0] % M\\n        print(ans)\\nif __name__ == \\\"__main__\\\":\\n    main()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0057057,\"audio_out\":null,\"duration\":128.7673318386078,\"api_duration\":128.65990090370178,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":907,\"output_tokens\":17152,\"total_tokens\":18059,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":16064,\"rejected_prediction_tokens\":0}}}]}"}