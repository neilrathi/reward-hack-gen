{"9980585cfd4c0724599f3378f80589dc35d5df2c": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: Monocarp plays a computer game. In this game, he maintains a space empire. The empire is governed by $$$n$$$ political parties. Initially, every party has political power equal to $$$0$$$, and there is no ruling party.\\n\\nDuring each of the next $$$m$$$ turns, the following happens:\\n\\n1. initially, Monocarp has to choose which party he supports. He can support any party, except for the ruling party. When Monocarp supports a party, its political power is increased by $$$1$$$. If Monocarp supports the $$$i$$$-th party during the $$$j$$$-th turn, his score increases by $$$a_{i,j}$$$ points;\\n2. then, the elections happen, and the party with the maximum political power is chosen as the ruling party (if there are multiple such parties, the party with the lowest index among them is chosen). The former ruling party is replaced, unless it is chosen again;\\n3. finally, an event happens. At the end of the $$$j$$$-th turn, the party $$$p_j$$$ must be the ruling party to prevent a bad outcome of the event, otherwise Monocarp loses the game.\\n\\nDetermine which party Monocarp has to support during each turn so that he doesn't lose the game due to the events, and the score he achieves is the maximum possible. Initially, Monocarp's score is $$$0$$$.\\n\\nTest Case Format:\\nThe first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\\\le n, m \\\\le 50$$$) \u2014 the number of political parties and the number of turns, respectively.\\n\\nThe second line contains $$$m$$$ integers $$$p_1, p_2, \\\\dots, p_m$$$ ($$$1 \\\\le p_j \\\\le n$$$), where $$$p_j$$$ is the index of the party which should be the ruling party at the end of the $$$j$$$-th turn.\\n\\nThen $$$n$$$ lines follow. The $$$i$$$-th of them contains $$$m$$$ integers $$$a_{i,1}, a_{i,2}, \\\\dots, a_{i,m}$$$ ($$$1 \\\\le a_{i,j} \\\\le 10^5$$$), where $$$a_{i,j}$$$ is the amount of points Monocarp gets if he supports the $$$i$$$-th party during the $$$j$$$-th turn.\\n\\nIf Monocarp loses the game no matter how he acts, print one integer $$$-1$$$.\\n\\nOtherwise, print $$$m$$$ integers $$$c_1, c_2, \\\\dots, c_m$$$ ($$$1 \\\\le c_j \\\\le n$$$), where $$$c_j$$$ is the index of the party Monocarp should support during the $$$j$$$-th turn. If there are multiple answers, print any of them.\\n\\nTest Inputs:\\n2 3\\r\\n2 1 2\\r\\n1 2 3\\r\\n4 5 6\\r\\n\\n\\nTest Outputs:\\n2 1 2 \\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    input = sys.stdin.readline\\n    n,m = map(int, input().split())\\n    p = list(map(int, input().split()))\\n    a = [None] + [list(map(int, input().split())) for _ in range(n)]\\n    w = [0]*(n+1)\\n    c = [0]*m\\n    for j in range(m):\\n        pj = p[j]\\n        prev = p[j-1] if j>0 else 0\\n        best = -1\\n        pick = -1\\n        for k in range(1,n+1):\\n            if k == prev: continue\\n            ok = False\\n            if k == pj:\\n                ok = True\\n            else:\\n                req = 1 if k < pj else 0\\n                if w[pj] - w[k] - req >= 1:\\n                    ok = True\\n            if ok:\\n                if a[k][j] > best:\\n                    best = a[k][j]\\n                    pick = k\\n        if pick == -1:\\n            print(-1)\\n            return\\n        c[j] = pick\\n        w[pick] += 1\\n    # verify\\n    power = [0]*(n+1)\\n    r = 0\\n    for j in range(m):\\n        if c[j] == r:\\n            print(-1); return\\n        power[c[j]] += 1\\n        # election\\n        mx = -1; who = 0\\n        for i in range(1,n+1):\\n            if power[i] > mx or (power[i]==mx and i<who):\\n                mx = power[i]; who = i\\n        r = who\\n        if r != p[j]:\\n            print(-1); return\\n    print(\\\" \\\".join(map(str,c)))\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0025157,\"audio_out\":null,\"duration\":37.27644109725952,\"api_duration\":37.167458057403564,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":683,\"output_tokens\":5155,\"total_tokens\":5838,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":4736,\"rejected_prediction_tokens\":0}}}]}", "8aa0e04bd11243f9bd8c2bd8b1a6ee09e403cf18": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: Alice is at the bottom of the rabbit hole! The rabbit hole can be modeled as a tree$$$^{\\\\text{\u2217}}$$$ which has an exit at vertex $$$1$$$, and Alice starts at some vertex $$$v$$$. She wants to get out of the hole, but unfortunately, the Queen of Hearts has ordered her execution.\\n\\nEach minute, a fair coin is flipped. If it lands heads, Alice gets to move to an adjacent vertex of her current location, and otherwise, the Queen of Hearts gets to pull Alice to an adjacent vertex of the Queen's choosing. If Alice ever ends up on any of the non-root leaves$$$^{\\\\text{\u2020}}$$$ of the tree, Alice loses.\\n\\nAssuming both of them move optimally, compute the probability that Alice manages to escape for every single starting vertex $$$1\\\\le v\\\\le n$$$. Since these probabilities can be very small, output them modulo $$$998\\\\,244\\\\,353$$$.\\n\\nFormally, let $$$M = 998\\\\,244\\\\,353$$$. It can be shown that the exact answer can be expressed as an irreducible fraction $$$\\\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\\\not \\\\equiv 0 \\\\pmod{M}$$$. Output the integer equal to $$$p \\\\cdot q^{-1} \\\\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\\\le x < M$$$ and $$$x \\\\cdot q \\\\equiv p \\\\pmod{M}$$$.\\n\\nTest Case Format:\\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 10^4$$$). The description of the test cases follows.\\n\\nThe first line of each test case contains a single integer $$$n$$$ ($$$2\\\\le n\\\\le 2\\\\cdot 10^5$$$) \u2014 the number of vertices in the tree.\\n\\nThe $$$i$$$-th of the next $$$n - 1$$$ lines contains two integers $$$x_i$$$ and $$$y_i$$$ ($$$1 \\\\le x_i, y_i \\\\le n$$$ and $$$x_i \\\\neq y_i$$$) \u2014 the edges of the tree. It is guaranteed that the given edges form a tree.\\n\\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2\\\\cdot 10^5$$$.\\n\\nFor each test case, output $$$n$$$ integers on one line \u2014 the probabilities of Alice escaping starting from vertex $$$1, 2, \\\\ldots, n$$$. Since these probabilities can be very small, output them modulo $$$998\\\\,244\\\\,353$$$.\\n\\nTest Inputs:\\n2\\r\\n5\\r\\n1 2\\r\\n1 3\\r\\n2 4\\r\\n3 5\\r\\n9\\r\\n1 2\\r\\n2 3\\r\\n4 5\\r\\n5 6\\r\\n7 8\\r\\n8 9\\r\\n2 4\\r\\n5 7\\r\\n\\n\\nTest Outputs:\\n1 499122177 499122177 0 0 \\r\\n1 499122177 0 332748118 166374059 0 443664157 720954255 0 \\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    sys.setrecursionlimit(1000000)\\n    M = 998244353\\n    inv2 = (M + 1) // 2\\n    input = sys.stdin.readline\\n    t = int(input())\\n    out = []\\n    for _ in range(t):\\n        n = int(input())\\n        adj = [[] for _ in range(n+1)]\\n        for _ in range(n-1):\\n            u,v = map(int, input().split())\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        parent = [0]*(n+1)\\n        children = [[] for _ in range(n+1)]\\n        order = []\\n        stack = [1]\\n        parent[1] = -1\\n        while stack:\\n            v = stack.pop()\\n            order.append(v)\\n            for u in adj[v]:\\n                if parent[u] == 0:\\n                    parent[u] = v\\n                    children[v].append(u)\\n                    stack.append(u)\\n        parent[1] = 0\\n        beta = [0]*(n+1)\\n        for v in reversed(order):\\n            if v == 1: continue\\n            if not children[v]:\\n                beta[v] = 0\\n            else:\\n                mb = M\\n                for c in children[v]:\\n                    if beta[c] < mb: mb = beta[c]\\n                denom = 2 - mb\\n                if denom < 0: denom += M\\n                beta[v] = pow(denom, M-2, M)\\n        f = [0]*(n+1)\\n        f[1] = 1\\n        for v in order:\\n            if v != 1:\\n                f[v] = beta[v] * f[parent[v]] % M\\n        out.append(\\\" \\\".join(str(f[i]) for i in range(1, n+1)))\\n    sys.stdout.write(\\\"\\\\n\\\".join(out))\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0026378,\"audio_out\":null,\"duration\":76.50228524208069,\"api_duration\":76.40218377113342,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":722,\"output_tokens\":9845,\"total_tokens\":10567,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":9408,\"rejected_prediction_tokens\":0}}}]}", "cd0e8afc563ac5d275bcf40f12f237592dd2f1ec": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: You are given a tree consisting of $$$2n$$$ vertices. Recall that a tree is a connected undirected graph with no cycles. Each vertex has an integer from $$$1$$$ to $$$n$$$ written on it. Each value from $$$1$$$ to $$$n$$$ is written on exactly two different vertices. Each vertex also has a cost\u00a0\u2014vertex $$$i$$$ costs $$$2^i$$$.\\n\\nYou need to choose a subset of vertices of the tree such that:\\n\\n- the subset is connected; that is, from each vertex in the subset, you can reach every other vertex in the subset by passing only through the vertices in the subset;\\n- each value from $$$1$$$ to $$$n$$$ is written on at least one vertex in the subset.\\n\\nAmong all such subsets, you need to find the one with the smallest total cost of the vertices in it. Note that you are not required to minimize the number of vertices in the subset.\\n\\nTest Case Format:\\nThe first line contains a single integer $$$n$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$).\\n\\nThe second line contains $$$2n$$$ integers $$$a_1, a_2, \\\\dots, a_{2n}$$$ ($$$1 \\\\le a_i \\\\le n$$$). Each value from $$$1$$$ to $$$n$$$ appears exactly twice.\\n\\nEach of the next $$$2n-1$$$ lines contains two integers $$$v$$$ and $$$u$$$ ($$$1 \\\\le v, u \\\\le 2n$$$)\u00a0\u2014 the edges of the tree. These edges form a valid tree.\\n\\nIn the first line, print a single integer $$$k$$$\u00a0\u2014 the number of vertices in the subset.\\n\\nIn the second line, print $$$k$$$ distinct integers from $$$1$$$ to $$$2n$$$\u00a0\u2014 the indices of the vertices in the chosen subset. The vertices can be printed in an arbitrary order.\\n\\nTest Inputs:\\n3\\r\\n1 1 3 2 3 2\\r\\n4 2\\r\\n1 6\\r\\n6 2\\r\\n6 3\\r\\n2 5\\r\\n\\n\\nTest Outputs:\\n3\\r\\n2 4 5 \\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport threading,sys\\ndef main():\\n    import sys\\n    sys.setrecursionlimit(10**7)\\n    n = int(sys.stdin.readline())\\n    a = list(map(int, sys.stdin.readline().split()))\\n    m = 2*n\\n    adj = [[] for _ in range(m)]\\n    for _ in range(m-1):\\n        u,v = map(int, sys.stdin.readline().split())\\n        u-=1; v-=1\\n        adj[u].append(v)\\n        adj[v].append(u)\\n    pos = [[] for _ in range(n)]\\n    for i,x in enumerate(a):\\n        pos[x-1].append(i)\\n    small = [min(p[0],p[1]) for p in pos]\\n    weight = [0]*m\\n    for x in range(n):\\n        weight[small[x]] = 1\\n    parent = list(range(m))\\n    lblcnt = weight[:]\\n    active = [False]*m\\n    def find(x):\\n        while parent[x]!=x:\\n            parent[x]=parent[parent[x]]\\n            x=parent[x]\\n        return x\\n    def union(x,y):\\n        rx,ry = find(x),find(y)\\n        if rx==ry: return\\n        parent[ry]=rx\\n        lblcnt[rx]+=lblcnt[ry]\\n    H = 0\\n    ansH = m\\n    for i in range(m):\\n        active[i]=True\\n        # initialize parent and lblcnt are already set\\n        for v in adj[i]:\\n            if v<i and active[v]:\\n                union(i,v)\\n        ri = find(i)\\n        if lblcnt[ri]==n:\\n            ansH = i+1\\n            break\\n    # build final component\\n    comp = []\\n    root = find(small[0])\\n    for i in range(ansH):\\n        if active[i] and find(i)==root:\\n            comp.append(i+1)\\n    print(len(comp))\\n    print(*comp)\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0024068,\"audio_out\":null,\"duration\":83.12149667739868,\"api_duration\":83.01113176345825,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":496,\"output_tokens\":10233,\"total_tokens\":10729,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":9792,\"rejected_prediction_tokens\":0}}}]}", "57fc8b674777069fc32a3d195a6b6f403b7b6b64": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: This is the hard version of the problem. The only differences between the two versions are the constraints on $$$k$$$ and the sum of $$$k$$$.\\n\\nIn ancient Persia, Khayyam, a clever merchant and mathematician, is playing a game with his prized treasure chest containing $$$n$$$ red rubies worth $$$2$$$ dinars each and $$$m$$$ blue sapphires worth $$$1$$$ dinar each. He also has a satchel, which starts empty, and $$$k$$$ scrolls with pairs $$$(r_1, b_1), (r_2, b_2), \\\\ldots, (r_k, b_k)$$$ that describe special conditions.\\n\\nThe game proceeds for $$$n + m$$$ turns as follows:\\n\\n1. Khayyam draws a gem uniformly at random from the chest.\\n2. He removes the gem from the chest and places it in his satchel.\\n3. If there exists a scroll $$$i$$$ ($$$1 \\\\leq i \\\\leq k$$$) such that the chest contains exactly $$$r_i$$$ red rubies and $$$b_i$$$ blue sapphires, Khayyam receives a royal decree that doubles the value of all the gems in his satchel as a reward for achieving a special configuration.\\n\\nNote that the value of some gems might be affected by multiple decrees, and in that case the gems' value is doubled multiple times.\\n\\nDetermine the expected value of Khayyam's satchel at the end of the game, modulo $$$998,244,353$$$.\\n\\nFormally, let $$$M = 998,244,353$$$. It can be shown that the exact answer can be expressed as an irreducible fraction $$$\\\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\\\not \\\\equiv 0 \\\\pmod{M}$$$. Output the integer equal to $$$p \\\\cdot q^{-1} \\\\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\\\le x < M$$$ and $$$x \\\\cdot q \\\\equiv p \\\\pmod{M}$$$.\\n\\nTest Case Format:\\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 500$$$). The description of the test cases follows.\\n\\nThe first line of each test case contains three integers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \\\\leq n, m \\\\leq 2 \\\\cdot 10^5$$$, $$$0 \\\\leq k \\\\leq 5000$$$)\u00a0\u2014 the number of red rubies, the number of blue sapphires, and the number of scrolls describing special conditions, respectively.\\n\\nEach of the next $$$k$$$ lines contains two integers $$$r_i$$$, $$$b_i$$$ ($$$0 \\\\leq r_i \\\\leq n$$$, $$$0 \\\\leq b_i \\\\leq m$$$, $$$1 \\\\leq r_i + b_i \\\\leq n+m-1$$$). It is guaranteed that the pairs $$$(r_i, b_i)$$$ are distinct.\\n\\nIt is guaranteed that the sum of $$$n$$$ and the sum of $$$m$$$ over all test cases do not exceed $$$2 \\\\cdot 10^5$$$, and the sum of $$$k$$$ over all test cases does not exceed $$$5000$$$.\\n\\nFor each test case, print a single integer: the expected value of Khayyam's satchel at the end of the process, modulo $$$998,244,353$$$.\\n\\nTest Inputs:\\n5\\r\\n3 4 0\\r\\n1 1 1\\r\\n1 0\\r\\n3 3 2\\r\\n1 1\\r\\n2 2\\r\\n3 3 2\\r\\n2 1\\r\\n1 2\\r\\n10 4 5\\r\\n1 0\\r\\n8 0\\r\\n6 4\\r\\n0 2\\r\\n7 4\\r\\n\\n\\nTest Outputs:\\n10\\r\\n499122180\\r\\n798595498\\r\\n149736666\\r\\n414854846\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    sys.setrecursionlimit(1000000)\\n    M = 998244353\\n    input = sys.stdin.readline\\n\\n    # Fast factorials and inverses for combinations\\n    MAX = 400000\\n    fact = [1] * (MAX + 1)\\n    invfact = [1] * (MAX + 1)\\n    for i in range(1, MAX + 1):\\n        fact[i] = fact[i - 1] * i % M\\n    invfact[MAX] = pow(fact[MAX], M - 2, M)\\n    for i in range(MAX, 0, -1):\\n        invfact[i - 1] = invfact[i] * i % M\\n\\n    def comb(n, k):\\n        if k < 0 or k > n:\\n            return 0\\n        return fact[n] * invfact[k] % M * invfact[n - k] % M\\n\\n    t = int(input())\\n    for _ in range(t):\\n        n, m, k = map(int, input().split())\\n        S = []\\n        for __ in range(k):\\n            r, b = map(int, input().split())\\n            S.append((r, b, r+b))\\n        S.append((0, 0, 0))\\n        S.append((n, m, n+m))\\n        S.sort(key=lambda x: x[2])\\n        idx = { (r,b): i for i,(r,b,_) in enumerate(S) }\\n        K = len(S)\\n        dp = [0] * K\\n        prob = [0] * K\\n        # prob[i] = probability to visit S[i]\\n        # dp[i] = expected final value from that visit's base sum\\n        prob[0] = 1  # (0,0)\\n        for i in range(K):\\n            r0, b0, s0 = S[i]\\n            for j in range(i+1, K):\\n                r1, b1, s1 = S[j]\\n                if r1 < r0 or b1 < b0: continue\\n                dr = r1 - r0\\n                db = b1 - b0\\n                ways = comb(dr+db, dr)\\n                tot = comb(n+m - s0, n - r0)\\n                p = ways * pow(tot, M-2, M) % M\\n                prob[j] = (prob[j] + prob[i] * p) % M\\n        ans = 0\\n        for i in range(K):\\n            r, b, s = S[i]\\n            if (r,b) in idx and 1 <= r+b <= n+m-1:\\n                # scroll\\n                ans = (ans + prob[i] * (2*r + b) * pow(2, M-2, M)) % M\\n        ans = (ans + (2*n + m) * (1 - sum(prob) % M) ) % M\\n        print(ans % M)\\nthreading.Thread(target=main).start()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0038687,\"audio_out\":null,\"duration\":84.6274139881134,\"api_duration\":84.51985597610474,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":909,\"output_tokens\":9054,\"total_tokens\":9963,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":8384,\"rejected_prediction_tokens\":0}}}]}", "6538ff678ce4298561044454351b04a234dd2b6c": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: This is the hard version of the problem. In this version, $$$n \\\\leq 10^6$$$. You can only make hacks if both versions of the problem are solved.\\n\\nOrangutans are powerful beings\u2014so powerful that they only need $$$1$$$ unit of time to destroy every vulnerable planet in the universe!\\n\\nThere are $$$n$$$ planets in the universe. Each planet has an interval of vulnerability $$$[l, r]$$$, during which it will be exposed to destruction by orangutans. Orangutans can also expand the interval of vulnerability of any planet by $$$1$$$ unit.\\n\\nSpecifically, suppose the expansion is performed on planet $$$p$$$ with interval of vulnerability $$$[l_p, r_p]$$$. Then, the resulting interval of vulnerability may be either $$$[l_p - 1, r_p]$$$ or $$$[l_p, r_p + 1]$$$.\\n\\nGiven a set of planets, orangutans can destroy all planets if the intervals of vulnerability of all planets in the set intersect at least one common point. Let the score of such a set denote the minimum number of expansions that must be performed.\\n\\nOrangutans are interested in the sum of scores of all non-empty subsets of the planets in the universe. As the answer can be large, output it modulo $$$998\\\\,244\\\\,353$$$.\\n\\nTest Case Format:\\nThe first line contains an integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 10^4$$$)\u00a0\u2014 the number of test cases.\\n\\nThe first line of each test case contains an integer $$$n$$$ ($$$1 \\\\leq n \\\\leq 10^6$$$)\u00a0\u2014 the number of planets in the universe.\\n\\nThe following $$$n$$$ lines contain two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \\\\leq l_i \\\\leq r_i \\\\leq n$$$)\u00a0\u2014 the initial interval of vulnerability of the $$$i$$$-th planet.\\n\\nIt is guaranteed that the sum of $$$n$$$ does not exceed $$$10^6$$$ over all test cases.\\n\\nFor each test case, output an integer\u00a0\u2014 the sum of scores to destroy all non-empty subsets of the planets in the universe, modulo $$$998\\\\,244\\\\,353$$$.\\n\\nTest Inputs:\\n3\\r\\n3\\r\\n1 1\\r\\n2 3\\r\\n3 3\\r\\n4\\r\\n1 4\\r\\n2 3\\r\\n2 4\\r\\n1 1\\r\\n5\\r\\n1 2\\r\\n2 3\\r\\n3 4\\r\\n4 5\\r\\n1 5\\r\\n\\n\\nTest Outputs:\\n5\\r\\n6\\r\\n24\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    data = sys.stdin\\n    mod = 998244353\\n    inv2 = (mod + 1) // 2\\n    t = int(data.readline())\\n    ns = []\\n    tests = []\\n    maxn = 0\\n    for _ in range(t):\\n        n = int(data.readline())\\n        if n > maxn: maxn = n\\n        ls = [0]*n\\n        rs = [0]*n\\n        for i in range(n):\\n            l,r = map(int, data.readline().split())\\n            ls[i] = l\\n            rs[i] = r\\n        tests.append((n, ls, rs))\\n    # precompute powers\\n    maxn2 = maxn + 5\\n    pow2 = [1] * (maxn2)\\n    inv2pow = [1] * (maxn2)\\n    for i in range(1, maxn2):\\n        pow2[i] = pow2[i-1] * 2 % mod\\n        inv2pow[i] = inv2pow[i-1] * inv2 % mod\\n    out = []\\n    for (n, ls, rs) in tests:\\n        al = [0] * (n+2)\\n        br = [0] * (n+2)\\n        for i in range(n):\\n            al[ls[i]] += 1\\n            br[rs[i]] += 1\\n        # prefix sums\\n        pref_l = [0] * (n+2)\\n        pref_r = [0] * (n+2)\\n        for i in range(1, n+1):\\n            pref_l[i] = pref_l[i-1] + al[i]\\n            pref_r[i] = pref_r[i-1] + br[i]\\n        # arrX and its prefix sums\\n        arrX = [0] * (n+2)\\n        sx1 = [0] * (n+2)\\n        sx2 = [0] * (n+2)\\n        for R in range(1, n+1):\\n            if br[R] > 0:\\n                arrX[R] = inv2pow[pref_r[R-1]]\\n            else:\\n                arrX[R] = 0\\n            sx1[R] = (sx1[R-1] + arrX[R]) % mod\\n            sx2[R] = (sx2[R-1] + arrX[R] * R) % mod\\n        # compute T1\\n        T1 = 0\\n        for L in range(2, n+1):\\n            aL = al[L]\\n            if aL == 0:\\n                continue\\n            # S_L\\n            BL = pref_l[L-1]\\n            # sum over R=1..L-1 of (L-R)*arrX_factor\\n            sum1 = sx1[L-1]\\n            sum2 = sx2[L-1]\\n            x = (L * sum1 - sum2) % mod\\n            SL = pow2[BL] * x % mod\\n            ta = (pow2[aL] - 1) % mod\\n            T1 = (T1 + ta * SL) % mod\\n        # arrY and its prefix sums\\n        arrY = [0] * (n+2)\\n        sy1 = [0] * (n+2)\\n        sy2 = [0] * (n+2)\\n        for L in range(1, n+1):\\n            if al[L] > 0:\\n                arrY[L] = pow2[pref_l[L-1]]\\n            else:\\n                arrY[L] = 0\\n            sy1[L] = (sy1[L-1] + arrY[L]) % mod\\n            sy2[L] = (sy2[L-1] + arrY[L] * L) % mod\\n        totalY1 = sy1[n]\\n        totalY2 = sy2[n]\\n        # compute T2\\n        T2 = 0\\n        for R in range(1, n):\\n            bR = br[R]\\n            if bR == 0:\\n                continue\\n            # sum over L=R+1..n of (L-R)*arrY[L]\\n            sumY1_tail = (totalY1 - sy1[R]) % mod\\n            sumY2_tail = (totalY2 - sy2[R]) % mod\\n            y = (sumY2_tail - R * sumY1_tail) % mod\\n            SR = inv2pow[pref_r[R]] * y % mod\\n            tb = (pow2[bR] - 1) % mod\\n            T2 = (T2 + tb * SR) % mod\\n        ans = (T1 - T2) % mod\\n        out.append(str(ans))\\n    sys.stdout.write(\\\"\\\\n\\\".join(out))\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0052547,\"audio_out\":null,\"duration\":122.50041222572327,\"api_duration\":122.39747405052185,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":585,\"output_tokens\":16362,\"total_tokens\":16947,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":15296,\"rejected_prediction_tokens\":0}}}]}", "61d5e0f2c92ebde5b4e1b5a29eff6530cf745880": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: A set $$$A$$$ consisting of pairwise distinct segments $$$[l, r]$$$ with integer endpoints is called good if $$$1\\\\le l\\\\le r\\\\le n$$$, and for any pair of distinct segments $$$[l_i, r_i], [l_j, r_j]$$$ in $$$A$$$, exactly one of the following conditions holds:\\n\\n- $$$r_i < l_j$$$ or $$$r_j < l_i$$$ (the segments do not intersect)\\n- $$$l_i \\\\le l_j \\\\le r_j \\\\le r_i$$$ or $$$l_j \\\\le l_i \\\\le r_i \\\\le r_j$$$ (one segment is fully contained within the other)\\n\\nYou are given a good set $$$S$$$ consisting of $$$m$$$ pairwise distinct segments $$$[l_i, r_i]$$$ with integer endpoints. You want to add as many additional segments to the set $$$S$$$ as possible while ensuring that set $$$S$$$ remains good.\\n\\nSince this task is too easy, you need to determine the number of different ways to add the maximum number of additional segments to $$$S$$$, ensuring that the set remains good. Two ways are considered different if there exists a segment that is being added in one of the ways, but not in the other.\\n\\nFormally, you need to find the number of good sets $$$T$$$ of distinct segments, such that $$$S$$$ is a subset of $$$T$$$ and $$$T$$$ has the maximum possible size. Since the result might be very large, compute the answer modulo $$$998\\\\,244\\\\,353$$$.\\n\\nTest Case Format:\\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 10^4$$$). The description of the test cases follows.\\n\\nThe first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$, $$$0 \\\\le m \\\\le 2 \\\\cdot 10^5$$$)\u00a0\u2014 the maximum right endpoint of the segments, and the size of $$$S$$$.\\n\\nThe $$$i$$$-th of the next $$$m$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \\\\le l_i \\\\le r_i \\\\le n$$$)\u00a0\u2014 the boundaries of the segments in set $$$S$$$.\\n\\nIt is guaranteed that the given set $$$S$$$ is good, and the segments in set $$$S$$$ are pairwise distinct.\\n\\nIt is guaranteed that both the sum of $$$n$$$ and the sum of $$$m$$$ over all test cases do not exceed $$$2 \\\\cdot 10^5$$$.\\n\\nFor each test case, output a single integer representing the number of different ways, modulo $$$998\\\\,244\\\\,353$$$, that you can add the maximum number of additional segments to set $$$S$$$ while ensuring that set $$$S$$$ remains good.\\n\\nTest Inputs:\\n6\\r\\n1 0\\r\\n2 3\\r\\n1 1\\r\\n2 2\\r\\n1 2\\r\\n5 2\\r\\n1 3\\r\\n2 3\\r\\n4 1\\r\\n1 1\\r\\n6 2\\r\\n1 3\\r\\n4 6\\r\\n2300 0\\r\\n\\n\\nTest Outputs:\\n1\\r\\n1\\r\\n2\\r\\n5\\r\\n4\\r\\n187997613\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"\",\"stop_reason\":\"max_tokens\",\"cost\":0.0008272,\"audio_out\":null,\"duration\":149.84851908683777,\"api_duration\":149.74420189857483,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":752,\"output_tokens\":20000,\"total_tokens\":20752,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":20000,\"rejected_prediction_tokens\":0}}}]}"}