{"ff3829caa380712fa21ecbf6ed4e3941fedd6a09": "{\"params\":{\"model\":\"o4-mini\",\"n\":1,\"num_candidates_per_completion\":1,\"insufficient_valids_behaviour\":\"retry\",\"temperature\":1.0,\"top_p\":null,\"max_tokens\":20000,\"thinking\":null,\"logprobs\":null,\"seed\":null,\"logit_bias\":null,\"stop\":null,\"unknown_kwargs\":{}},\"prompt\":{\"messages\":[{\"role\":\"system\",\"content\":\"Please solve this Codeforces problem by writing a Python solution. Return only the code and nothing else.\"},{\"role\":\"user\",\"content\":\"Problem: Suppose we partition the elements of an array $$$b$$$ into any number $$$k$$$ of non-empty multisets $$$S_1, S_2, \\\\ldots, S_k$$$, where $$$k$$$ is an arbitrary positive integer. Define the score of $$$b$$$ as the maximum value of $$$\\\\operatorname{MEX}(S_1)$$$$$$^{\\\\text{\u2217}}$$$$$$ + \\\\operatorname{MEX}(S_2) + \\\\ldots + \\\\operatorname{MEX}(S_k)$$$ over all possible partitions of $$$b$$$ for any integer $$$k$$$.\\n\\nEnvy is given an array $$$a$$$ of size $$$n$$$. Since he knows that calculating the score of $$$a$$$ is too easy for you, he instead asks you to calculate the sum of scores of all $$$2^n - 1$$$ non-empty subsequences of $$$a$$$.$$$^{\\\\text{\u2020}}$$$ Since this answer may be large, please output it modulo $$$998\\\\,244\\\\,353$$$.\\n\\nTest Case Format:\\nThe first line contains an integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 10^4$$$)\u00a0\u2014 the number of test cases.\\n\\nThe first line of each test case contains an integer $$$n$$$ ($$$1 \\\\leq n \\\\leq 2 \\\\cdot 10^5$$$)\u00a0\u2014 the length of $$$a$$$.\\n\\nThe second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$0 \\\\leq a_i < n$$$)\u00a0\u2014 the elements of the array $$$a$$$.\\n\\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\\\cdot 10^5$$$.\\n\\nFor each test case, output the answer, modulo $$$998\\\\,244\\\\,353$$$.\\n\\nTest Inputs:\\n4\\r\\n3\\r\\n0 0 1\\r\\n4\\r\\n0 0 1 1\\r\\n5\\r\\n0 0 1 2 2\\r\\n4\\r\\n1 1 1 1\\r\\n\\n\\nTest Outputs:\\n11\\r\\n26\\r\\n53\\r\\n0\\r\\n\"}]},\"responses\":[{\"model_id\":\"o4-mini\",\"completion\":\"```python\\nimport sys\\nimport threading\\ndef main():\\n    import sys\\n    data = sys.stdin.read().split()\\n    it = iter(data)\\n    mod = 998244353\\n    t = int(next(it))\\n    # Precompute factorials and invfacs and pow2 up to max N\\n    # First find max n in input\\n    # But since sum n <= 2e5, we can set maxN = 200000\\n    maxN = 200000\\n    fact = [1] * (maxN + 1)\\n    for i in range(1, maxN + 1):\\n        fact[i] = fact[i-1] * i % mod\\n    invf = [1] * (maxN + 1)\\n    invf[maxN] = pow(fact[maxN], mod-2, mod)\\n    for i in range(maxN, 0, -1):\\n        invf[i-1] = invf[i] * i % mod\\n    pow2 = [1] * (maxN + 1)\\n    for i in range(1, maxN + 1):\\n        pow2[i] = pow2[i-1] * 2 % mod\\n    out = []\\n    for _ in range(t):\\n        n = int(next(it))\\n        a = [0] * n\\n        for i in range(n):\\n            a[i] = int(next(it))\\n        cnt = [0] * (n + 1)\\n        for v in a:\\n            if v <= n:\\n                cnt[v] += 1\\n        # find K = max index such that cnt[0..K]>0\\n        K = -1\\n        for j in range(n+1):\\n            if cnt[j] == 0:\\n                break\\n            K = j\\n        if K < 0:\\n            out.append(\\\"0\\\")\\n            continue\\n        # Build T_j arrays for j=0..K\\n        T = []\\n        for j in range(K+1):\\n            c = cnt[j]\\n            # compute prefix binomial sums pb[k] = sum_{x=0..k} C(c,x)\\n            # we only need pb up to k=c-1\\n            pb = [0] * (c + 1)\\n            s = 0\\n            for k in range(0, c+1):\\n                v = fact[c] * invf[k] % mod * invf[c-k] % mod\\n                s += v\\n                if s >= mod: s -= mod\\n                pb[k] = s\\n            # build Tj of length c: Tj[m-1] = 2^c - pb[m-1]\\n            tc = pow2[c]\\n            Tj = [0] * c\\n            for m1 in range(c):\\n                # pb[m1] is sum up to k=m1\\n                v = tc - pb[m1]\\n                if v < 0: v += mod\\n                Tj[m1] = v\\n            T.append(Tj)\\n        ans = 0\\n        tot_pref = 0\\n        # curT for i=0..K\\n        curT = None\\n        for i in range(K+1):\\n            c = cnt[i]\\n            tot_pref += c\\n            t_i = n - tot_pref\\n            if i == 0:\\n                # init curT\\n                curT = T[0].copy()\\n            else:\\n                # multiply and truncate\\n                ci = c\\n                newM = ci if ci < len(curT) else len(curT)\\n                for idx in range(newM):\\n                    curT[idx] = curT[idx] * T[i][idx] % mod\\n                # truncate\\n                if newM < len(curT):\\n                    curT = curT[:newM]\\n            if not curT:\\n                break\\n            s = sum(curT) % mod\\n            ans = (ans + s * pow2[t_i]) % mod\\n        out.append(str(ans))\\n    sys.stdout.write(\\\"\\\\n\\\".join(out))\\n\\nif __name__ == \\\"__main__\\\":\\n    threading.Thread(target=main).start()\\n```\",\"stop_reason\":\"stop_sequence\",\"cost\":0.0044066,\"audio_out\":null,\"duration\":54.921416997909546,\"api_duration\":54.81886386871338,\"logprobs\":null,\"safety_ratings\":null,\"recitation_retries\":null,\"api_failures\":0,\"batch_custom_id\":null,\"reasoning_content\":null,\"usage\":{\"input_tokens\":506,\"output_tokens\":6205,\"total_tokens\":6711,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":5312,\"rejected_prediction_tokens\":0}}}]}"}